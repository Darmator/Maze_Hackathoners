<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-image: url(https://sites.google.com/site/darmatorsprites/home/grasstile.png); 
}
</style>
</head>
<body onload="menu()" >

<script>
var first_level = true;
var startGameVar = false;
var myGamePiece;//This is our red square
var myEnemy = [];
var enemy_amount = 0;
var myObstacle =new Array();//This are going to be the obstacles
var map = new Array();//This is going to be the maze written with, 0, 1 and 2, then the program will translate it into squares
var visited = new Array();
var visible = new Array();
var temp_visible = new Array();
//and store it in myObstacle variable
//These are the textures
var spikes_image = new Image();
spikes_image.src ="https://opengameart.org/sites/default/files/styles/medium/public/spike-animation_0.png";
var spikes_state = 0;
var spikes_deadly = false;
var spikes_counter = 1;
var orcs_image = new Image();
orcs_image.src = "https://sites.google.com/site/darmatorsprites/home/orc%20sprite.png";
var dragon_image = new Image();
dragon_image.src = "https://sites.google.com/site/darmatorsprites/home/sf2-characters.png";
var fire_ball = [];
var fire_timer = [];
var fire_direction = [];
var death = false;
var move_to_x = [];
var move_to_y = [];
var question_image = new Image ();
question_image.src = "https://sites.google.com/site/darmatorsprites/home/question.PNG";
var hero_image = new Image();
hero_image.src = "https://sites.google.com/site/darmatorsprites/home/sprite.png";
var hero_vision = 2;
var enemy_foot = [];
var enemy_look = [];
var enemy_direction = [];
var hero_foot = 0;
var hero_look = "down";
var loose_image = new Image();
loose_image.src ="http://orig07.deviantart.net/17c7/f/2013/145/f/6/game_over_wallpaper_by_3971450-d66kbai.png";
var tree_image = new Image();
tree_image.src = "https://opengameart.org/sites/default/files/styles/medium/public/tree-variations_0.png";
var wall_image = new Image();
wall_image.src = "https://sites.google.com/site/darmatorsprites/home/sf2-map.png";
var ground_image = new Image();
ground_image.src = "https://opengameart.org/sites/default/files/grndcobblestone.jpg";
var sign_image = new Image ();
sign_image.src = "https://opengameart.org/sites/default/files/oga-textures/greendragon.jpg";
var mazeWidth = 19;//Width of the maze  WRITE IN THIS TWO VARIABLES ODD NUMBERS min 17
var mazeHeight = 7;//Heigth of the maze min 7
var squareSurface = 52;//length of one square WRITE IN THIS VARIABLE WITH EVEN NEUMBERS
var direction = [];//This array will be used to generate random mazes,
// it will tell the program what paths can it follow
var posX;//x position of the square that the program is going to modify in order to create the map
var posY;//y position of the square that the program is going to modify in order to create the map
var locationX;
var locationY;
var enemy_locationX = [];
var enemy_locationY = [];
var last_px = [];//This two arrays will let the program remember where are the squares that it has already
var last_py = [];//modify in order to make more than just one path
move = 0;//This variable will make the last_p arrays work
var crashLeft = false;
var crashRight = false;
var crashTop = false;
var crashBottom = false;
var level_counter = 0;
//This for loop transforms the array myObstacle into a 2d array, because, there isn't a code to make them

//Menu
function menu(){
    myGameArea.start();
    ctx = myGameArea.context;
    ctx.fillStyle="green";
    ctx.fillRect(0,0,myGameArea.canvas.width,myGameArea.canvas.height);
    ctx.fillStyle="yellow";
    ctx.fillRect((myGameArea.canvas.width/2)-(200/2),(myGameArea.canvas.height/2)-(100/2),200,100);
    ctx.fillStyle="black";
    ctx.font = "15px Arial";
    ctx.fillText("Click Here To Begin",(myGameArea.canvas.width/2)-(200/2)+35,(myGameArea.canvas.height/2)+5);
    window.addEventListener('mouseup', function(e) {
    var x = e.clientX;
    var y = e.clientY;
        if (x>((myGameArea.canvas.width/2)-(200/2)) && x<((myGameArea.canvas.width/2)-(200/2)+200) && y>((myGameArea.canvas.height/2)-(100/2)) && y<((myGameArea.canvas.height/2)-(100/2)+100) && startGameVar == false){
            startGameVar = true;
            startGame();
        }
    });
    window.addEventListener('mousemove', function inBox(e) {
        var j = e.clientX;
        var k = e.clientY;
        if (j>((myGameArea.canvas.width/2)-(200/2)) && j<((myGameArea.canvas.width/2)-(200/2)+200) && k>((myGameArea.canvas.height/2)-(100/2)) && k<((myGameArea.canvas.height/2)-(100/2)+100)){
            if(startGameVar == false){
            ctx.fillStyle="#FFD700";
            ctx.fillRect((myGameArea.canvas.width/2)-(200/2),(myGameArea.canvas.height/2)-(100/2),200,100);
            ctx.fillStyle="black";
            ctx.font = "15px Arial";
            ctx.fillText("Click Here To Begin",(myGameArea.canvas.width/2)-(200/2)+35,(myGameArea.canvas.height/2)+5);
            }
        }
        else{
            if(startGameVar == false){
            ctx.fillStyle="yellow";
            ctx.fillRect((myGameArea.canvas.width/2)-(200/2),(myGameArea.canvas.height/2)-(100/2),200,100);
            ctx.fillStyle="black";
            ctx.font = "15px Arial";
            ctx.fillText("Click Here To Begin",(myGameArea.canvas.width/2)-(200/2)+35,(myGameArea.canvas.height/2)+5);
            }
        }
    });  
}
function turn_to_2d(){
	for (n=0;n<mazeHeight;n++) {
 myObstacle[n]=new Array();
  map[n]=new Array();
  visible[n] = new Array();
  temp_visible[n] = new Array();
 for (m=0;m<mazeWidth;m++) {
  myObstacle[n][m]=0;
  map[n][m]=0;
  visible[n][m] = false;
  temp_visible[n][m] = false;
 }
}
}
function turn_to_3d(){
	for (j = 0; j < enemy_amount; j++){
	visited[j] = new Array();
	for (n = 0; n < mazeHeight; n++){
		visited[j][n] = new Array();
		for (m = 0; m < mazeWidth; m++){
			visited[j][n][m];
		}
	}
}
}
function create_enemies(){
	for (t = 0; t < enemy_amount; t++){
	fire_ball[t] = 0;
	enemy_foot[t] = 0;
	fire_timer[t] = 0;
	enemy_look[t] = "down";
	enemy_direction[t] = new Array();
	for (v = 0; v < 4; v++){
		enemy_direction[t][v] = 0;
	}
	enemy_direction[t].length = 0;
}
	for (t = 0; t < enemy_amount; t++){
		get_location();
		enemy_locationX[t] = locationX
		enemy_locationY[t] = locationY
		myEnemy[t] = new component(squareSurface/2, squareSurface/2, "enemy", myObstacle[locationY][locationX].x  , myObstacle[locationY][locationX].y, t );
		move_to_x[t] = myObstacle[locationY][locationX].x ;
		move_to_y[t] = myObstacle[locationY][locationX].y ;
	}
}
    
//Start the game
function startGame() {
	myGameArea.start();//Load the canvas and all that stuff
    myGameArea.interval = setInterval(updateGameArea, 20);
	turn_to_2d();
	turn_to_3d();
	sketch_map();//Write 0, 1 and 2, inside the map array using an algorithm
    draw_map();//Translate the map array into objects and store it into my obstacle array
	get_location();
	myGamePiece = new component(squareSurface/2, squareSurface/2, "hero", myObstacle[locationY][locationX].x + 4 , myObstacle[locationY][locationX].y + 4 );
	create_enemies();
}
function reset_game(){
	mazeHeight += 2;
	mazeWidth += 2;
	level_counter++;
	enemy_amount++;
	spikes_counter++;
	if (level_counter === 3){
		spikes_counter = 2;
		enemy_amount = 1;
		mazeWidth = 19;
		mazeHeight = 7;
		first_level = false;
	}
	turn_to_2d();
	turn_to_3d();
	create_enemies();
	myGameArea.start();
	end = false;
	sketch_map();
	draw_map();
	get_location();
	myGamePiece = new component(squareSurface/2, squareSurface/2, "hero", myObstacle[locationY][locationX].x + 4 , myObstacle[locationY][locationX].y + 4 );
	for (t = 0; t < enemy_amount; t++){
		get_location();
		enemy_locationX[t] = locationX
		enemy_locationY[t] = locationY
		myEnemy[t].x = myObstacle[locationY][locationX].x;
		myEnemy[t].y = myObstacle[locationY][locationX].y;
		move_to_x[t] = myObstacle[locationY][locationX].x ;
		move_to_y[t] = myObstacle[locationY][locationX].y ;
	}
}
function get_location(){
	do {
	locationX = Math.floor(Math.random() * mazeWidth );
	locationY = Math.floor(Math.random() * mazeHeight );
	}
	while (map[locationY][locationX] !== 0);
}
//Start loading things
var myGameArea = {  
    canvas : document.createElement("canvas"),//Load the canvas
    start : function() {
        this.canvas.width = mazeWidth * squareSurface;//The canvas width will be equal to the number of squares times their width
        this.canvas.height = mazeHeight * squareSurface;//The canvas height will be equal to the number of squares times their heigth
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        
		//Check if no keys are pressed
        window.addEventListener('keydown', function (e) {
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        });
		//Check if any keys are pressed
        window.addEventListener('keyup', function (e) {
            myGameArea.keys[e.keyCode] = (e.type == "keydown");            
        });
    }, 
	//Clear the canvas
    clear : function(){
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },
	//Stop the game
	stop : function() {
        clearInterval(this.interval);
    }
};
//This function will manage the algorithm that will write ones, or zeroes to the screen
function sketch_map(){
	//This for loop will set all the elements of map to 1,
//	basically how this algorithm works is that you start from a canvas fll of squares and the algorithm "carves" the maze
	for (v = 0; v < mazeHeight; v++){
		for(n = 0; n < mazeWidth; n++){
		map[v][n] = 1;
		}
	}
	//Set he beggining position of the algorithm at map[1][1]
	posX = 1;
	posY = 1;
	map[posX][posY] = 0;
	/*How this algorithm works is like this:
	1. State a beginning position
	2. Check what directions can you choose to go from that direction
	3. If there are directions available choose one randomly
	4. Continue till there are not directions available
	5. When there aren't any new directions available follow your path backwards till you find new directions
	6. Continue from step 2
	7. If there arenÂ´t any new directions in the maze you have finished*/
	do {
	while(check_carve()){
		carve();
		direction.length = 0;
	} 
	} while (!ultimate_check());
	
  }
  //Check if there's any direction that you can choose
  function check_carve (){
	var direction_carve = false;
	//Check if you can go north
	if (posY - 2 > 0 && map[posY - 2][posX] == 1 && map[posY-1][posX] == 1){
		direction.push("N");
		direction_carve = true;
	}
	//Check if you can go south
	if (posY + 2 < mazeHeight && map[posY + 2][posX] == 1 && map[posY +1][posX] == 1){
		direction.push("S");
		direction_carve = true;
	}
	//Check if you can go west
	if (posX - 2 > 0 && map[posY][posX - 2] == 1 && map[posY][posX - 1] == 1){
		direction.push("W");
		direction_carve = true;
	}
	//Check if you can go east
	if (posX + 2 < mazeWidth && map[posY][posX + 2] && map[posY][posX + 1] == 1){ 
		direction.push("E");
		direction_carve = true;
	}
	//Output there are any directions available
	return direction_carve;
}
//Follow your path backwards
function ultimate_check(){
	var end_sketching = true;
	move--;
	//If you can keep following backwards the path
	if (move !== 0){
	posY = last_py[move];//Go to the last square that you carved
	posX = last_px[move];
	end_sketching = false;
	}
	//Output if there's still path for you to follow
	return end_sketching;
	
}
//Carve the maze, carving is done by changing the values of map from 1 to 0
function carve(){
//	Pick your available directions and choose one randomly
	var choose= Math.floor(Math.random() * direction.length);
	last_py[move] = posY;//Record your square
	last_px[move] = posX;
	switch (direction[choose]){
	//	carve the squares at your left
		case "W":
		map[posY][posX-1] = 0;
		map[posY][posX-2] = 0;
		posX -= 2;
		break;
		// carve the squares at your right
	case "E":
		map[posY][posX+1] = 0;
		map[posY][posX+2] = 0;
		posX +=2;
		break;
		//carve the squares over you
	case "N":
		map[posY-1][posX] = 0;
		map[posY-2][posX] = 0;
		last_py[move] = posY;
		posY -= 2;
		break;
		//carve the squares under you
	case "S":
		map[posY+1][posX] = 0;
		map[posY+2][posX] = 0;
		posY += 2;
		break;
	}
	move++;
}
//This fuction will translate the 1 and 0, of the map array into objects inside the myObstacle array
function draw_map(){
	var counter = 0;
	var horizontal = 0;//horizontal coordinates
	var vertical = 0;//vertical coordinates
	//Look all the values of the map array
	var finish_line_location = Math.floor(Math.random() * 3 );
	switch  (finish_line_location){
	case 0:
		map[0][1] = 2;
		break;
	case 1:
		map[0][mazeWidth - 2] = 2;
		break;
	case 2:
		map[mazeHeight - 2][0] = 2;
		break;
	case 3:
		map[mazeHeight - 2][mazeWidth - 1] = 2;
		break;
	}
	for (var y = 0;  y < mazeHeight; y++){
		for (var x = 0; x < mazeWidth; x++){
			if (counter < spikes_counter){
			get_location();
			map[locationY][locationX] = 4;
			counter++;
			}
			switch (map[y][x]){
			case 0:
				myObstacle[y][x] = new component (squareSurface, squareSurface, "ground", horizontal, vertical);
				break;
			case 1:
				myObstacle[y][x] = new component (squareSurface, squareSurface, "wall", horizontal, vertical);
				break;
			case 2:
				myObstacle[y][x] = new component (squareSurface, squareSurface, "sign", horizontal, vertical);
				break;
			case 3:
				myObstacle[y][x] = new component (squareSurface, squareSurface, "question", horizontal, vertical);
				break;
			case 4:
				myObstacle[y][x] = new component (squareSurface, squareSurface, "spikes", horizontal, vertical);
				break;
			}
			horizontal += squareSurface;
			}
		horizontal = 0;
		vertical += squareSurface;
		}
}
//This function will allow the different objects have characteristics
function component(width, height, color, x, y, number) {
    this.gamearea = myGameArea;
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;    
    this.x = x;
    this.y = y;    
    this.update = function() {
        ctx = myGameArea.context;
		
			
			switch (color) {
			case "wall":
			if (first_level){
				ctx.drawImage(tree_image, 0, 78, 67, 70, this.x, this.y, squareSurface, squareSurface);
			}
			else{
				ctx.drawImage(wall_image, 55, 300, 30, 30, this.x, this.y, squareSurface, squareSurface);
			}
				break;
			case "ground":
			if (!first_level){
				ctx.drawImage(ground_image, this.x, this.y, this.width, this.height);
				}
				break;
			case "sign":
				ctx.drawImage(sign_image, this.x, this.y, this.width, this.height);
				break;
			case "question":
				ctx.drawImage(question_image, this.x, this.y, this.width, this.height);
				break;
			case "hero":
				hero_sprites( this.x, this.y, this.width, this.height);
				break;
			case "enemy":
				if (first_level){
					orcs_sprites( this.x, this.y, this.width, this.height, number);
				}
				else {
					dragon_sprites(this.x, this.y, this.width, this.height, number);
				}
				break;
			case "spikes":
				if (!first_level){
					ctx.drawImage(ground_image, this.x, this.y, this.width, this.height);
				}
				spikes_sprites( this.x, this.y, this.width, this.height);
				break;
			case "fire":
				flame_sprites( this.x, this.y, this.width, this.height, number);
			}
		if (block_vision(this.x, this.y) && !first_level){ 
			ctx.fillStyle = "black";
        ctx.fillRect(this.x, this.y, this.width, this.height);
		}
    };
    this.newPos = function() {
        this.x += this.speedX;
        this.y += this.speedY;        
    };
        this.crashLeft = function(otherobj){
            var myLeft = this.x;
            var otherRight = otherobj.x + (otherobj.width);
            var myTop = this.y;
            var otherBottom = otherobj.y + (otherobj.height);
            var myBottom = this.y + (this.height);
            var otherTop = otherobj.y;
            var crashLeft = true;
            if ((myLeft !== otherRight) ||(myTop >= otherBottom ) || (myBottom <= otherTop ))  {
                crashLeft = false;
            }
            return crashLeft;
        };
         this.crashRight = function(otherobj){
            var myRight = this.x + (this.width);
            var otherLeft = otherobj.x;
            var myTop = this.y;
            var otherBottom = otherobj.y + (otherobj.height);
            var myBottom = this.y + (this.height);
            var otherTop = otherobj.y;
            var crashRight = true;
            if ((myRight !== otherLeft) ||(myTop >= otherBottom ) || (myBottom <= otherTop )){
                crashRight = false;
            }
            return crashRight;
        };
        this.crashBottom = function(otherobj){
            var myTop = this.y;
            var otherBottom = otherobj.y + (otherobj.height);
            var myLeft = this.x;
            var otherRight = otherobj.x + (otherobj.width);
            var myRight = this.x + (this.width);
            var otherLeft = otherobj.x;
            var crashBottom = true;
            if ((myTop !== otherBottom) || (myLeft >= otherRight )||(myRight <= otherLeft)){
                crashBottom = false;
            }
            return crashBottom;
        };
       this.crashTop = function(otherobj){
            var myBottom = this.y + (this.height);
            var otherTop = otherobj.y;
            var myLeft = this.x;
            var otherRight = otherobj.x + (otherobj.width);
            var myRight = this.x + (this.width);
            var otherLeft = otherobj.x;
            var crashTop = true;
            if ((myBottom !== otherTop) || (myLeft >= otherRight)|| (myRight <= otherLeft)){
                crashTop = false;
            }
            return crashTop;
        };
    
}
function visibility (){
	var heroX;
	var heroY;
	for (v = 0; v < mazeHeight; v++){
		for (b = 0; b < mazeWidth; b++){
			temp_visible[v][b] = false;
			visible[v][b] = false;
			if ((myGamePiece.x >= myObstacle[v][b].x && myGamePiece.x <= myObstacle[v][b].x + squareSurface) &&
			(myGamePiece.y >= myObstacle[v][b].y && myGamePiece.y <= myObstacle[v][b].y + squareSurface)){
				heroX = b;
				heroY = v;
			}
		}
	}
	
	for (t = 0; t < mazeHeight; t++){
		for (u = 0; u < mazeWidth; u++){
			if (u === heroX && (t >= heroY - (hero_vision + 1) && t <= heroY + hero_vision + 1)){
				visible[t][u] = true;
			}
			else if (t === heroY && (u >= heroX - (hero_vision + 1) && u <= heroX + hero_vision + 1)){
			 visible[t][u] = true;
			}
		}
	}
	for (t = 0; t < mazeHeight; t++){
		for (u = 0; u < mazeWidth; u++){
			if (visible[t][u]){
				if (u > heroX + 1 &&(map[t][u - 1] === 1 || map[t][u - 2] === 1)){
					visible[t][u] = false;
				}
				else if (u < heroX - 1 &&(map[t][u + 1] === 1 || map[t][u + 2] === 1)){
					visible[t][u] = false;
				}
				else if (t > heroY + 1 &&(map[t - 1][u] === 1 || map[t - 2][u] === 1)){
					visible[t][u] = false;
				}
				else if (t < heroY - 1 &&(map[t + 1][u] === 1 || map[t + 2][u] === 1)){
					visible[t][u] = false;
				}
			}
		}
	}
	for (t = 0; t < mazeHeight; t++){
		for (u = 0; u < mazeWidth; u++){
			if (visible[t][u]){
				if (u === heroX){
					if (u + 1 < mazeWidth) {
						temp_visible[t][u + 1] = true;
					}
					if (u - 1 >= 0) {
						temp_visible[t][u - 1] = true;
					}
				}
				else if (t === heroY){
					if (t + 1 < mazeHeight) {
						temp_visible[t + 1][u] = true;
					}
					if (t - 1 >= 0) {
						temp_visible[t - 1][u] = true;
					}
				}
			}
		}
	}
}
function block_vision( x, y){
	var block = true;
	var coordinateX;
	var coordinateY;
	for (v = 0; v < mazeHeight; v++){
		for (b = 0; b < mazeWidth; b++){
			if ((x + 5 >= myObstacle[v][b].x && x + 5 <= myObstacle[v][b].x + squareSurface) && (y + 5 >= myObstacle[v][b].y && y + 5 <= myObstacle[v][b].y + squareSurface)){
				coordinateX = b;
				coordinateY = v;
				if (visible[coordinateY][coordinateX] || temp_visible[coordinateY][coordinateX]){
				block= false;
			}
			}
		}
	}
	return block;
}
function hero_sprites(  x,  y,  width,  height){
			switch (hero_look){
			case "down":
				if ( myGamePiece.speedY > 0 && hero_foot <= 10){
					ctx.drawImage(hero_image, 205, 638, 50, 70,  x,  y,  width,  height);//down 1
				}
				else if ( myGamePiece.speedY > 0  && hero_foot > 10){
					ctx.drawImage(hero_image, 459, 638, 50, 70,  x,  y,  width,  height);// down 2
				}
				else {
					ctx.drawImage(hero_image, 76, 638, 50, 70,  x,  y,  width,  height);// down 
				}
				break;
			case "up":
				if ( myGamePiece.speedY < 0 && hero_foot <= 10){
					ctx.drawImage(hero_image, 198, 519, 50, 69,  x,  y,  width,  height);//up 1
				}
				else if ( myGamePiece.speedY < 0 && hero_foot > 10){
					ctx.drawImage(hero_image,453, 519, 50, 69,  x,  y,  width,  height);//up 2
				}
				else {
					ctx.drawImage(hero_image, 70, 519, 50, 69,  x,  y,  width,  height);//up
				}
				break;
			case "right":
				if ( myGamePiece.speedX > 0 && hero_foot <= 10){
					ctx.drawImage(hero_image, 128, 707, 50, 70,  x,  y,  width,  height);//right 1
				}
				else if (myGamePiece.speedX > 0 && hero_foot > 10){
					ctx.drawImage(hero_image, 381, 707, 50, 70,  x,  y,  width,  height);//right 2
				}
				else {
					ctx.drawImage(hero_image, 0, 707, 50, 70,  x,  y,  width,  height);//right
				}
				break;
			case "left":
				if ( myGamePiece.speedX < 0 && hero_foot <= 10){
					ctx.drawImage(hero_image, 147, 580, 50, 70,  x,  y,  width,  height);//left 1
				}
				else if ( myGamePiece.speedX < 0 && hero_foot > 10){
					ctx.drawImage(hero_image, 402, 580, 50, 70,  x,  y,  width,  height);//left 2
				}
				else {
					ctx.drawImage(hero_image, 20, 580, 50, 70,  x,  y,  width,  height);//left
				}
				break;
			}
			hero_foot++;
			if (hero_foot  >= 20 ){
			hero_foot = 0;
			}
}
function orcs_sprites( x,  y,  width,  height, number){
				switch (enemy_look[number]){
			case "down":
				if ( myEnemy[number].speedY === 1  && enemy_foot[number] <= 10){
					ctx.drawImage(orcs_image, 207, 638, 50, 70,  x,  y,  width,  height);//down 1
				}
				else if ( myEnemy[number].speedY === 1  && enemy_foot[number] > 10){
					ctx.drawImage(orcs_image, 461, 638, 50, 70,  x,  y,  width,  height);// down 2
				}
				break;
			case "up":
				if ( myEnemy[number].speedY === -1 && enemy_foot[number] <= 10){
					ctx.drawImage(orcs_image, 204, 519, 50, 69,  x,  y,  width,  height);//up 1
				}
				else if ( myEnemy[number].speedY === -1 && enemy_foot[number] > 10){
					ctx.drawImage(orcs_image, 459, 519, 50, 69,  x,  y,  width,  height);//up 2
				}
				break;
			case "right":
				if ( myEnemy[number].speedX === 1 && enemy_foot[number] <= 10){
					ctx.drawImage(orcs_image, 128, 707, 50, 70,  x,  y,  width,  height);//right 1
				}
				else if (myEnemy[number].speedX === 1 && enemy_foot[number] > 10){
					ctx.drawImage(orcs_image, 381, 707, 50, 70,  x,  y,  width,  height);//right 2
				}
				break;
			case "left":
				if ( myEnemy[number].speedX === -1 && enemy_foot[number] <= 10){
					ctx.drawImage(orcs_image, 147, 580, 50, 70,  x,  y,  width,  height);//left 1
				}
				else if ( myEnemy[number].speedX === -1 && enemy_foot[number] > 10){
					ctx.drawImage(orcs_image, 402, 580, 50, 70,  x,  y,  width,  height);//left 2
				}
				break;
			}
			enemy_foot[number]++;
			if (enemy_foot[number]  >= 20 ){
			enemy_foot[number] = 0;
			}
}

function dragon_sprites( x,  y,  width,  height, number){
				switch (enemy_look[number]){
			case "down":
				if ( myEnemy[number].speedY === 1  && enemy_foot[number] <= 10){
					ctx.drawImage(dragon_image, 0, 121, 25, 25, x, y, width, height); //down 1
				}
				else if ( myEnemy[number].speedY === 1  && enemy_foot[number] > 10){
					ctx.drawImage(dragon_image, 24, 121, 25, 25, x, y, width, height); //down 2
				}
				break;
			case "up":
				if ( myEnemy[number].speedY === -1 && enemy_foot[number] <= 10){
					ctx.drawImage(dragon_image, 96, 121, 25, 25, x, y, width, height); //up 1
				}
				else if ( myEnemy[number].speedY === -1 && enemy_foot[number] > 10){
					ctx.drawImage(dragon_image, 120, 121, 25, 25, x, y, width, height); //up 2
				}
				break;
			case "right":
				if ( myEnemy[number].speedX === 1 && enemy_foot[number] <= 10){
					ctx.drawImage(dragon_image, 144, 121, 25, 25, x, y, width, height); //right 1
				}
				else if (myEnemy[number].speedX === 1 && enemy_foot[number] > 10){
					ctx.drawImage(dragon_image, 168, 121, 25, 25, x, y, width, height); //right 2
				}
				break;
			case "left":
				if ( myEnemy[number].speedX === -1 && enemy_foot[number] <= 10){
					ctx.drawImage(dragon_image, 48, 121, 25, 25, x, y, width, height); //left 1
				}
				else if ( myEnemy[number].speedX === -1 && enemy_foot[number] > 10){
					ctx.drawImage(dragon_image, 72, 121, 25, 25, x, y, width, height); //left 2
				}
				break;
			}
			fire_timer[number]++;
			if (fire_timer[number] >= 200){
				fire_ball[number] = new component(width, height, "fire", x + 5 , y + 5, number );
				fire_direction[number] = enemy_look[number];
				fire_timer[number] = 0;
			}
			enemy_foot[number]++;
			if (enemy_foot[number]  >= 20 ){
				enemy_foot[number] = 0;
			}
}
function flame_sprites (x, y, width, height, number){
	switch(fire_direction[number]){
	case "down":
		fire_ball[number].speedY = 4;
		ctx.drawImage(dragon_image, 0, 144, 25, 25,x, y, width, height); //down fire
		break;
	case "up":
		fire_ball[number].speedY = -4;
		ctx.drawImage(dragon_image, 96, 145, 25, 22,x, y, width, height); //up fire
		break;
	case "left":
		fire_ball[number].speedX = -4;
		ctx.drawImage(dragon_image, 48, 144, 25, 25,x, y, width, height); //left fire
		break;
	case "right":
		fire_ball[number].speedX = 4;
		ctx.drawImage(dragon_image, 144, 144, 25, 25,x, y, width, height); //right fire
		break;
	}
}
function spikes_sprites(x, y, width, height){
	if (spikes_state <= 25 * spikes_counter){
		ctx.drawImage(spikes_image, 5, 0, 23, 30, x, y, width, height);
		spikes_deadly = false;
	}
	else if (spikes_state <= 50 * spikes_counter){
		ctx.drawImage(spikes_image, 27, 0, 23, 30, x, y, width, height);
	}
	else if (spikes_state <= 75 * spikes_counter){
		ctx.drawImage(spikes_image, 49, 0, 23, 30, x, y, width, height);
	}
	else if (spikes_state <= 150 * spikes_counter){
		ctx.drawImage(spikes_image, 93, 0, 23, 30, x, y, width, height);
		spikes_deadly = true;
	}
	else {
		spikes_state = 0;
	}
	spikes_state++;
}
function check_obstacle_crash( i, b, object){
	var any_crash = false;
	if (object.crashLeft(myObstacle[i][b])){
        crashLeft = true;
		any_crash = true;
    }
    if (object.crashRight(myObstacle[i][b])){
        crashRight = true;
		any_crash = true;
    }
    if (object.crashTop(myObstacle[i][b])){
        crashTop = true;
		any_crash = true;
    }
    if (object.crashBottom(myObstacle[i][b])){
        crashBottom = true;
		any_crash = true;
	}
	return any_crash;
}
function check_enemy_crash(number){
	if (myGamePiece.crashLeft(myEnemy[number])){
		death = true;
    }
    if (myGamePiece.crashRight(myEnemy[number])){
        death = true;
    }
    if (myGamePiece.crashTop(myEnemy[number])){
        death = true;
    }
    if (myGamePiece.crashBottom(myEnemy[number])){
        death = true;
	}
}
function check_flame_death(number){
if ((fire_ball[number].x >= myGamePiece.x && fire_ball[number].x <= myGamePiece.x + myGamePiece.width)  &&
	(fire_ball[number].y >= myGamePiece.y && fire_ball[number].y <= myGamePiece.y + myGamePiece.height)){
		death = true;
	}
}

function check_enemy_direction(number){
	visited[number][enemy_locationY[number]][enemy_locationX[number]] = true;
	var walk = false;
	if (map[enemy_locationY[number] - 1][enemy_locationX[number]] === 0 && !visited[number][enemy_locationY[number] - 1][enemy_locationX[number]]){
		enemy_direction[number].push("N");
		walk = true;
	}
	if (map[enemy_locationY[number] + 1][enemy_locationX[number]] === 0 && !visited[number][enemy_locationY[number] + 1][enemy_locationX[number]]){
		enemy_direction[number].push("S");
		walk = true
	}
	if (map[enemy_locationY[number]][enemy_locationX[number] - 1] === 0 && !visited[number][enemy_locationY[number]][enemy_locationX[number] - 1]){
		enemy_direction[number].push("W");
		walk = true;
	}
	if (map[enemy_locationY[number]][enemy_locationX[number] + 1] === 0 && !visited[number][enemy_locationY[number]][enemy_locationX[number] + 1]){
		enemy_direction[number].push("E");
		walk = true;
	}
	if (!walk) {
		for (n = 0; n < mazeHeight; n++){
			for (m = 0; m < mazeWidth; m++){
				visited[number][n][m] = false;
			}
		}
	}
}
function enemy_move(number){
	myEnemy[number].speedX = 0;
	myEnemy[number].speedY = 0;
	var choose_direction = Math.floor(Math.random() * enemy_direction[number].length );
	switch (enemy_direction[number][choose_direction]){
	case "N":
		enemy_look[number] = "up";
		myEnemy[number].speedY = -1;
		enemy_locationY[number]--;
		move_to_y[number] = myObstacle[enemy_locationY[number]][enemy_locationX[number]].y;
		break;
	case "S":
		enemy_look[number] = "down";
		myEnemy[number].speedY = 1;
		enemy_locationY[number]++;
		move_to_y[number] = myObstacle[enemy_locationY[number]][enemy_locationX[number]].y;
		break;
	case "W":
		enemy_look[number] = "left";
		myEnemy[number].speedX = -1;
		enemy_locationX[number]--;
		move_to_x[number] = myObstacle[enemy_locationY[number]][enemy_locationX[number]].x;
		break;
	case "E":
		enemy_look[number] = "right";
		myEnemy[number].speedX = 1;
		enemy_locationX[number]++;
		move_to_x[number] = myObstacle[enemy_locationY[number]][enemy_locationX[number]].x;
		break;
	}
	enemy_direction[number].length = 0;
}
function check_spikes_crash(i,b){
	var spikes_crash = false;
	if ((myGamePiece.x >= myObstacle[i][b].x && myGamePiece.x <= myObstacle[i][b].x + squareSurface)  &&
	(myGamePiece.y >= myObstacle[i][b].y && myGamePiece.y <= myObstacle[i][b].y + squareSurface)){
		spikes_crash = true;
	}
	return spikes_crash;
}
function check_flame_crash (number) {
	for (f = 0; f < mazeHeight; f++){
		for (u = 0; u < mazeWidth; u++){
			if ((fire_ball[number].x >= myObstacle[f][u].x && fire_ball[number].x <= myObstacle[f][u].x + squareSurface)  &&
	(fire_ball[number].y >= myObstacle[f][u].y && fire_ball[number].y <= myObstacle[f][u].y + squareSurface) && map[f][u] === 1){
			fire_ball[number] = 0;
		}
	}
}
}
function updateGameArea() {
    myGameArea.clear();
	visibility();
    crashLeft = false;
    crashRight = false;
    crashTop = false;
    crashBottom = false;
	end = false;
	myGamePiece.speedX = 0;
	myGamePiece.speedY = 0;
	//Check for collisions, and, if there's a collision with a blue block, set end value to true
    for (i= 0; i< mazeHeight;i++){
		for (var b = 0; b <mazeWidth; b++){
			switch (map[i][b]){
			case 0:
				break;
			case 1:
				check_obstacle_crash(i,b, myGamePiece);
				break;
			case 2:
				if (check_obstacle_crash(i,b, myGamePiece)){
					end = true;
				}
				break;
			case 3:
				break;
			case 4:
				if (check_spikes_crash(i,b) && spikes_deadly){
					death = true;
				}
				break;
			}
        }
	}
	
	
	//move the red square
	    if (myGameArea.keys && myGameArea.keys[37] && !crashLeft ) {
				myGamePiece.speedX = -2;
				hero_look = "left";
	}
    else if (myGameArea.keys && myGameArea.keys[39] && !crashRight ) {
				myGamePiece.speedX =2;
				hero_look = "right";
	}
    else if (myGameArea.keys && myGameArea.keys[38] && !crashBottom ) {
				myGamePiece.speedY = -2;
				hero_look = "up";
	}
    else if (myGameArea.keys && myGameArea.keys[40] && !crashTop ){
				myGamePiece.speedY = 2;
				hero_look = "down";
	}
	//Update myObtacle position
    for (i = 0; i < mazeHeight; i++){
		for (var c=0; c <mazeWidth; c++){
    myObstacle[i][c].update();
	}
    } 
//Update the red square position	
	myGamePiece.newPos();
    myGamePiece.update();
	for ( t = 0; t < enemy_amount; t++){
		check_enemy_crash(t);
		check_flame_death(t);
		if (myEnemy[t].x === move_to_x[t] && myEnemy[t].y === move_to_y[t]){
			check_enemy_direction(t);
			enemy_move(t);
		}
		if (fire_ball[t] !== 0){
			fire_ball[t].newPos();
			fire_ball[t].update();
			check_flame_crash(t);
		}
		myEnemy[t].newPos();
		myEnemy[t].update();
	}
	if (end){//if end is true stop the game and write Game Over!!!
	reset_game();
	}
	if (death){
		ctx.drawImage(loose_image, 0, 0, mazeWidth * squareSurface, mazeHeight * squareSurface);
		myGameArea.stop();
	}
}
</script>
</body>
</html>