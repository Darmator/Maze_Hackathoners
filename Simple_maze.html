<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1; 
}
</style>
</head>
<body onload="menu()" >

<script>
var startGameVar = false;
var myGamePiece;//This is our red square
var myObstacle =new Array();//This are going to be the obstacles
var map = new Array();//This is going to be the maze written with, 0, 1 and 2, then the program will translate it into squares
//and store it in myObstacle variable
//These are the textures
var character_image = new Image();
character_image.src = "https://i.imgur.com/sCrkzvs.png";
var foot = 0;
var begin = true;
var character_look = "down";
var win_image = new Image();
win_image.src ="http://orig07.deviantart.net/17c7/f/2013/145/f/6/game_over_wallpaper_by_3971450-d66kbai.png";
var wall_image = new Image();
wall_image.src = "https://opengameart.org/sites/default/files/grndcobblestone.jpg";
var ground_image = new Image();
ground_image.src = "https://opengameart.org/sites/default/files/grass.png";
var sign_image = new Image ();
sign_image.src = "https://opengameart.org/sites/default/files/oga-textures/greendragon.jpg";
var mazeWidth = 11;//Width of the maze (41 squares) WRITE IN THIS TWO VARIABLES ODD NUMBERS
var mazeHeigth = 11;//Heigth of the maze (41 squares)
var squareSurface = 50;//length of one square WRITE IN THIS VARIABLE WITH EVEN NEUMBERS
var direction = [];//This array will be used to generate random mazes,
// it will tell the program what paths can it follow
var posX;//x position of the square that the program is going to modify in order to create the map
var posY;//y position of the square that the program is going to modify in order to create the map
var last_px = [];//This two arrays will let the program remember where are the squares that it has already
var last_py = [];//modify in order to make more than just one path
move = 0;//This variable will make the last_p arrays work
//This for loop transforms the array myObstacle into a 2d array, because, there isn't a code to make them
for (n=0;n<mazeHeigth;n++) {
 myObstacle[n]=new Array();
 for (m=0;m<mazeWidth;m++) {
  myObstacle[n][m]=0;
 }
}
//This for loop transforms the array map, into a 2d array
for (n=0;n<mazeHeigth;n++) {
 map[n]=new Array();
 for (m=0;m<mazeWidth;m++) {
  map[n][m]=0;
 }
}
    
//Menu
function menu(){
    myGameArea.start();
    ctx = myGameArea.context;
    ctx.fillStyle="green";
    ctx.fillRect(0,0,myGameArea.canvas.width,myGameArea.canvas.height);
    ctx.fillStyle="yellow";
    ctx.fillRect((myGameArea.canvas.width/2)-(200/2),(myGameArea.canvas.height/2)-(100/2),200,100);
    ctx.fillStyle="black";
    ctx.font = "15px Arial";
    ctx.fillText("Click Here To Begin",(myGameArea.canvas.width/2)-(200/2)+35,(myGameArea.canvas.height/2)+5);
    window.addEventListener('mouseup', function(e) {
    var x = e.clientX;
    var y = e.clientY;
        if (x>((myGameArea.canvas.width/2)-(200/2)) && x<((myGameArea.canvas.width/2)-(200/2)+200) && y>((myGameArea.canvas.height/2)-(100/2)) && y<((myGameArea.canvas.height/2)-(100/2)+100) && startGameVar == false){
            startGameVar = true;
            startGame();
        }
    });
    window.addEventListener('mousemove', function inBox(e) {
        var j = e.clientX;
        var k = e.clientY;
        if (j>((myGameArea.canvas.width/2)-(200/2)) && j<((myGameArea.canvas.width/2)-(200/2)+200) && k>((myGameArea.canvas.height/2)-(100/2)) && k<((myGameArea.canvas.height/2)-(100/2)+100)){
            if(startGameVar == false){
            ctx.fillStyle="#FFD700";
            ctx.fillRect((myGameArea.canvas.width/2)-(200/2),(myGameArea.canvas.height/2)-(100/2),200,100);
            ctx.fillStyle="black";
            ctx.font = "15px Arial";
            ctx.fillText("Click Here To Begin",(myGameArea.canvas.width/2)-(200/2)+35,(myGameArea.canvas.height/2)+5);
            }
        }
        else{
            if(startGameVar == false){
            ctx.fillStyle="yellow";
            ctx.fillRect((myGameArea.canvas.width/2)-(200/2),(myGameArea.canvas.height/2)-(100/2),200,100);
            ctx.fillStyle="black";
            ctx.font = "15px Arial";
            ctx.fillText("Click Here To Begin",(myGameArea.canvas.width/2)-(200/2)+35,(myGameArea.canvas.height/2)+5);
            }
        }
    });  
}
    
//Start the game
function startGame() {
    myGameArea.start();//Load the canvas and all that stuff
    myGameArea.interval = setInterval(updateGameArea, 10);
	sketch_map();//Write 0, 1 and 2, inside the map array using an algorithm
    draw_map();//Translate the map array into objects and store it into my obstacle array
	myGamePiece = new component(squareSurface / 2, squareSurface/2, "character", myObstacle[1][1].x, myObstacle[1][1].y);
	//Create the red square, it will have half of the size of the green blocks, and,it will be placed at the beginning of the maze
	//the square [1][1] will always be the beggining of the maze
}
//Start loading things
var myGameArea = {  
    canvas : document.createElement("canvas"),//Load the canvas
    start : function() {
        this.canvas.width = mazeWidth * squareSurface;//The canvas width will be equal to the number of squares times their width
        this.canvas.height = mazeHeigth * squareSurface;//The canvas height will be equal to the number of squares times their heigth
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        
		//Check if no keys are pressed
        window.addEventListener('keydown', function (e) {
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        });
		//Check if any keys are pressed
        window.addEventListener('keyup', function (e) {
            myGameArea.keys[e.keyCode] = (e.type == "keydown");            
        });
    }, 
	//Clear the canvas
    clear : function(){
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },
	//Stop the game
	stop : function() {
        clearInterval(this.interval);
    }
};
//This function will manage the algorithm that will write ones, or zeroes to the screen
function sketch_map(){
	//This for loop will set all the elements of map to 1,
//	basically how this algorithm works is that you start from a canvas fll of squares and the algorithm "carves" the maze
	for (v = 0; v < mazeHeigth; v++){
		for(n = 0; n < mazeWidth; n++){
		map[v][n] = 1;
		}
	}
	//Set he beggining position of the algorithm at map[1][1]
	posX = 1;
	posY = 1;
	map[posX][posY] = 0;
	/*How this algorithm works is like this:
	1. State a beginning position
	2. Check what directions can you choose to go from that direction
	3. If there are directions available choose one randomly
	4. Continue till there are not directions available
	5. When there aren't any new directions available follow your path backwards till you find new directions
	6. Continue from step 2
	7. If there arenÂ´t any new directions in the maze you have finished*/
	do {
	while(check_carve()){
		carve();
		direction.length = 0;
	} 
	} while (!ultimate_check());
	
  }
  //Check if there's any direction that you can choose
  function check_carve (){
	var direction_carve = false;
	//Check if you can go north
	if (posY - 2 > 0 && map[posY - 2][posX] == 1 && map[posY-1][posX] == 1){
		direction.push("N");
		direction_carve = true;
	}
	//Check if you can go south
	if (posY + 2 < mazeHeigth && map[posY + 2][posX] == 1 && map[posY +1][posX] == 1){
		direction.push("S");
		direction_carve = true;
	}
	//Check if you can go west
	if (posX - 2 > 0 && map[posY][posX - 2] == 1 && map[posY][posX - 1] == 1){
		direction.push("W");
		direction_carve = true;
	}
	//Check if you can go east
	if (posX + 2 < mazeWidth && map[posY][posX + 2] && map[posY][posX + 1] == 1){ 
		direction.push("E");
		direction_carve = true;
	}
	//Output there are any directions available
	return direction_carve;
}
//Follow your path backwards
function ultimate_check(){
	var end_sketching = true;
	move--;
	//If you can keep following backwards the path
	if (move !== 0){
	posY = last_py[move];//Go to the last square that you carved
	posX = last_px[move];
	end_sketching = false;
	}
	//Output if there's still path for you to follow
	return end_sketching;
	
}
//Carve the maze, carving is done by changing the values of map from 1 to 0
function carve(){
//	Pick your available directions and choose one randomly
	var choose= Math.floor(Math.random() * direction.length);
	last_py[move] = posY;//Record your square
	last_px[move] = posX;
	switch (direction[choose]){
	//	carve the squares at your left
		case "W":
		map[posY][posX-1] = 0;
		map[posY][posX-2] = 0;
		posX -= 2;
		break;
		// carve the squares at your right
	case "E":
		map[posY][posX+1] = 0;
		map[posY][posX+2] = 0;
		posX +=2;
		break;
		//carve the squares over you
	case "N":
		map[posY-1][posX] = 0;
		map[posY-2][posX] = 0;
		last_py[move] = posY;
		posY -= 2;
		break;
		//carve the squares under you
	case "S":
		map[posY+1][posX] = 0;
		map[posY+2][posX] = 0;
		posY += 2;
		break;
	}
	move++;
}
//This fuction will translate the 1 and 0, of the map array into objects inside the myObstacle array
function draw_map(){
	//Make the furthest square to the beginning the end of the maze by changing its value to 2
	map[mazeHeigth - 2][mazeWidth - 2] = 2;
	var horizontal = 0;//horizontal coordinates
	var vertical = 0;//vertical coordinates
	//Look all the values of the map array
	for (var y = 0;  y < mazeHeigth; y++){
		for (var x = 0; x < mazeWidth; x++){
		if (map[y][x] > 0){//Square surface is the size of the square and horizontal and vertical their coordinates
		if (map[y][x] > 1){//if a value is bigger than one
		myObstacle[y][x] = new component (squareSurface, squareSurface, "sign", horizontal, vertical);
		}
		else{//if a value is bigger than 0 but less than 2
		myObstacle[y][x] = new component (squareSurface, squareSurface, "wall", horizontal, vertical);
		}
		}
		else {//if a value is less than 1
		myObstacle[y][x] = new component (squareSurface, squareSurface, "ground", horizontal, vertical);
		}
		horizontal += squareSurface;//move the width of a square to the right
		}
		horizontal = 0;//go back to the beginning
		vertical += squareSurface;//move the heigth of a square down
		}
}
//This function will allow the different objects have characteristics
function component(width, height, color, x, y) {
    this.gamearea = myGameArea;
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;    
    this.x = x;
    this.y = y;    
    this.update = function() {
        ctx = myGameArea.context;
		if (color === "wall"){
			ctx.drawImage(wall_image, this.x, this.y, this.width, this.height);
		}
		else if (color === "ground"){
		ctx.drawImage(ground_image, this.x, this.y, this.width, this.height);
		}
		else if (color === "sign"){
		ctx.drawImage(sign_image, this.x, this.y, this.width, this.height);
		}
		else if (color === "character"){
		if (begin === true){
			ctx.drawImage(character_image, 0, 0, 55, 60, this.x, this.y, this.width, this.height);// down 
		}
		else {
			switch (character_look){
			case "down":
				if (myGameArea.keys[40]  && foot <= 10){
					ctx.drawImage(character_image, 62, 0, 55, 60, this.x, this.y, this.width, this.height);//down 1
				}
				else if (myGameArea.keys[40]  && foot > 10){
					ctx.drawImage(character_image, 190, 0, 55, 60, this.x, this.y, this.width, this.height);// down 2
				}
				else {
					ctx.drawImage(character_image, 0, 0, 55, 60, this.x, this.y, this.width, this.height);// down 
				}
				break;
			case "up":
				if (myGameArea.keys[38] && foot <= 10){
					ctx.drawImage(character_image, 62, 190, 55, 60, this.x, this.y, this.width, this.height);//up 1
				}
				else if (myGameArea.keys[38] && foot > 10){
					ctx.drawImage(character_image, 190, 190, 55, 60, this.x, this.y, this.width, this.height);//up 2
				}
				else {
					ctx.drawImage(character_image, 0, 190, 55, 60, this.x, this.y, this.width, this.height);//up
				}
				break;
			case "right":
				if (myGameArea.keys[39] && foot <= 10){
					ctx.drawImage(character_image, 62, 126, 55, 60, this.x, this.y, this.width, this.height);//right 1
				}
				else if (myGameArea.keys[39] && foot > 10){
					ctx.drawImage(character_image, 190, 126, 55, 60, this.x, this.y, this.width, this.height);//right 2
				}
				else {
					ctx.drawImage(character_image, 0, 126, 55, 60, this.x, this.y, this.width, this.height);//right
				}
				break;
			case "left":
				if (myGameArea.keys[37] && foot <= 10){
					ctx.drawImage(character_image, 62, 62, 55, 60, this.x, this.y, this.width, this.height);//left 1
				}
				else if (myGameArea.keys[37] && foot > 10){
					ctx.drawImage(character_image, 190, 62, 55, 60, this.x, this.y, this.width, this.height);//left 2
				}
				else {
					ctx.drawImage(character_image, 0, 62, 55, 60, this.x, this.y, this.width, this.height);//left
				}
				break;
			}
			foot++;
			if (foot  >= 20 ){
			foot = 0;
			}
		}
		}
		else{
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
		}
    };
    this.newPos = function() {
        this.x += this.speedX;
        this.y += this.speedY;        
    };
        this.crashLeft = function(otherobj){
            var myLeft = this.x;
            var otherRight = otherobj.x + (otherobj.width);
            var myTop = this.y;
            var otherBottom = otherobj.y + (otherobj.height);
            var myBottom = this.y + (this.height);
            var otherTop = otherobj.y;
            var crashLeft = true;
            if ((myLeft !== otherRight) ||(myTop >= otherBottom ) || (myBottom <= otherTop ))  {
                crashLeft = false;
            }
            return crashLeft;
        };
         this.crashRight = function(otherobj){
            var myRight = this.x + (this.width);
            var otherLeft = otherobj.x;
            var myTop = this.y;
            var otherBottom = otherobj.y + (otherobj.height);
            var myBottom = this.y + (this.height);
            var otherTop = otherobj.y;
            var crashRight = true;
            if ((myRight !== otherLeft) ||(myTop >= otherBottom ) || (myBottom <= otherTop )){
                crashRight = false;
            }
            return crashRight;
        };
        this.crashBottom = function(otherobj){
            var myTop = this.y;
            var otherBottom = otherobj.y + (otherobj.height);
            var myLeft = this.x;
            var otherRight = otherobj.x + (otherobj.width);
            var myRight = this.x + (this.width);
            var otherLeft = otherobj.x;
            var crashBottom = true;
            if ((myTop !== otherBottom) || (myLeft >= otherRight )||(myRight <= otherLeft)){
                crashBottom = false;
            }
            return crashBottom;
        };
       this.crashTop = function(otherobj){
            var myBottom = this.y + (this.height);
            var otherTop = otherobj.y;
            var myLeft = this.x;
            var otherRight = otherobj.x + (otherobj.width);
            var myRight = this.x + (this.width);
            var otherLeft = otherobj.x;
            var crashTop = true;
            if ((myBottom !== otherTop) || (myLeft >= otherRight)|| (myRight <= otherLeft)){
                crashTop = false;
            }
            return crashTop;
        };
    
}
function updateGameArea() {
    myGameArea.clear();
    var crashLeft = false;
    var crashRight = false;
    var crashTop = false;
    var crashBottom = false;
	var end = false;
	myGamePiece.speedX = 0;
	myGamePiece.speedY = 0;
	//Check for collisions, and, if there's a collision with a blue block, set end value to true
    for (i= 0; i< mazeHeigth;i++){
		for (var b = 0; b <mazeWidth; b++){
        if (myGamePiece.crashLeft(myObstacle[i][b]) && map[i][b] !== 0){
            crashLeft = true;
			if (map[i][b] === 2){
			end = true;
			}
        }
        if (myGamePiece.crashRight(myObstacle[i][b])&& map[i][b] !== 0){
            crashRight = true;
			if (map[i][b] === 2){
			end = true;
			}
        }
        if (myGamePiece.crashTop(myObstacle[i][b])&& map[i][b] !== 0){
            crashTop = true;
			if (map[i][b] === 2){
			end = true;
			}
        }
        if (myGamePiece.crashBottom(myObstacle[i][b])&& map[i][b] !== 0){
            crashBottom = true;
			if (map[i][b] === 2){
			end = true;
			}
        }
		}
    }
	//move the red square
	    if (myGameArea.keys && myGameArea.keys[37] && !crashLeft ) {
				myGamePiece.speedX = -1;
				character_look = "left";
				begin = false;
	}
    else if (myGameArea.keys && myGameArea.keys[39] && !crashRight ) {
				myGamePiece.speedX =1;
				character_look = "right";
				begin = false;
	}
    else if (myGameArea.keys && myGameArea.keys[38] && !crashBottom ) {
				myGamePiece.speedY = -1;
				character_look = "up";
				begin = false;
	}
    else if (myGameArea.keys && myGameArea.keys[40] && !crashTop ){
				myGamePiece.speedY = 1;
				character_look = "down";
				begin = false;
	}
	//Update myObtacle position
    for (i = 0; i < mazeHeigth; i++){
		for (var c=0; c <mazeWidth; c++){
    myObstacle[i][c].update();
	}
    } 
//Update the red square position	
	myGamePiece.newPos();
    myGamePiece.update();
	if (end){//if end is true stop the game and write Game Over!!!
	myGameArea.stop();
	 ctx = myGameArea.context;
	ctx.drawImage(win_image, 0, 0, myGameArea.canvas.width, myGameArea.canvas.height);
	}
}
</script>
</body>
</html>