<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1; 
}
</style>
</head>
<body onload="menu()" >

<script>
var startGameVar = false;
var myGamePiece;//This is our red square
var myEnemy;
var myObstacle =new Array();//This are going to be the obstacles
var map = new Array();//This is going to be the maze written with, 0, 1 and 2, then the program will translate it into squares
var visited = new Array()
//and store it in myObstacle variable
//These are the textures
var enemy_image = new Image();
enemy_image.src = "https://sites.google.com/site/darmatorsprites/home/orc%20sprite.png";
var move_to_x;
var move_to_y;
var question_image = new Image ();
question_image.src = "https://sites.google.com/site/darmatorsprites/home/question.PNG";
var hero_image = new Image();
hero_image.src = "https://sites.google.com/site/darmatorsprites/home/sprite.png";
var enemy_foot = 0;
var foot = 0;
var hero_look = "down";
var enemy_look = "down";
var win_image = new Image();
win_image.src ="http://orig07.deviantart.net/17c7/f/2013/145/f/6/game_over_wallpaper_by_3971450-d66kbai.png";
var wall_image = new Image();
wall_image.src = "https://opengameart.org/sites/default/files/grndcobblestone.jpg";
var ground_image = new Image();
ground_image.src = "https://opengameart.org/sites/default/files/grass.png";
var sign_image = new Image ();
sign_image.src = "https://opengameart.org/sites/default/files/oga-textures/greendragon.jpg";
var mazeWidth = 15;//Width of the maze (41 squares) WRITE IN THIS TWO VARIABLES ODD NUMBERS
var mazeHeigth = 11;//Heigth of the maze (41 squares)
var squareSurface = 50;//length of one square WRITE IN THIS VARIABLE WITH EVEN NEUMBERS
var direction = [];//This array will be used to generate random mazes,
// it will tell the program what paths can it follow
var posX;//x position of the square that the program is going to modify in order to create the map
var posY;//y position of the square that the program is going to modify in order to create the map
var locationX;
var locationY;
var last_px = [];//This two arrays will let the program remember where are the squares that it has already
var last_py = [];//modify in order to make more than just one path
move = 0;//This variable will make the last_p arrays work
var crashLeft = false;
var crashRight = false;
var crashTop = false;
var crashBottom = false;
//This for loop transforms the array myObstacle into a 2d array, because, there isn't a code to make them
function turn_into_2d(){
for (n=0;n<mazeHeigth;n++) {
 myObstacle[n]=new Array();
 map[n]=new Array();
 for (m=0;m<mazeWidth;m++) {
  myObstacle[n][m]=0;
  map[n][m]=0;
 }
}
}
function turnVisitedInto2d(){
    for (n = 0; n < mazeHeigth; n++){
        visited[n] = new Array();
        for (m = 0; m < mazeWidth; m++){
            visited[n][m] = false;
        }
    }
}
    
//Menu
function menu(){
    myGameArea.start();
    ctx = myGameArea.context;
    ctx.fillStyle="green";
    ctx.fillRect(0,0,myGameArea.canvas.width,myGameArea.canvas.height);
    ctx.fillStyle="yellow";
    ctx.fillRect((myGameArea.canvas.width/2)-(200/2),(myGameArea.canvas.height/2)-(100/2),200,100);
    ctx.fillStyle="black";
    ctx.font = "15px Arial";
    ctx.fillText("Click Here To Begin",(myGameArea.canvas.width/2)-(200/2)+35,(myGameArea.canvas.height/2)+5);
    window.addEventListener('mouseup', function(e) {
    var x = e.clientX;
    var y = e.clientY;
        if (x>((myGameArea.canvas.width/2)-(200/2)) && x<((myGameArea.canvas.width/2)-(200/2)+200) && y>((myGameArea.canvas.height/2)-(100/2)) && y<((myGameArea.canvas.height/2)-(100/2)+100) && startGameVar == false){
            startGameVar = true;
            startGame();
        }
    });
    window.addEventListener('mousemove', function inBox(e) {
        var j = e.clientX;
        var k = e.clientY;
        if (j>((myGameArea.canvas.width/2)-(200/2)) && j<((myGameArea.canvas.width/2)-(200/2)+200) && k>((myGameArea.canvas.height/2)-(100/2)) && k<((myGameArea.canvas.height/2)-(100/2)+100)){
            if(startGameVar == false){
            ctx.fillStyle="#FFD700";
            ctx.fillRect((myGameArea.canvas.width/2)-(200/2),(myGameArea.canvas.height/2)-(100/2),200,100);
            ctx.fillStyle="black";
            ctx.font = "15px Arial";
            ctx.fillText("Click Here To Begin",(myGameArea.canvas.width/2)-(200/2)+35,(myGameArea.canvas.height/2)+5);
            }
        }
        else{
            if(startGameVar == false){
            ctx.fillStyle="yellow";
            ctx.fillRect((myGameArea.canvas.width/2)-(200/2),(myGameArea.canvas.height/2)-(100/2),200,100);
            ctx.fillStyle="black";
            ctx.font = "15px Arial";
            ctx.fillText("Click Here To Begin",(myGameArea.canvas.width/2)-(200/2)+35,(myGameArea.canvas.height/2)+5);
            }
        }
    });  
}
    
//Start the game
function startGame() {
    myGameArea.start();//Load the canvas and all that stuff
    myGameArea.interval = setInterval(updateGameArea, 10);
    turn_into_2d();
    turnVisitedInto2d();
	sketch_map();//Write 0, 1 and 2, inside the map array using an algorithm
    draw_map();//Translate the map array into objects and store it into my obstacle array
	get_location();
	myGamePiece = new component(squareSurface/2, squareSurface/2, "hero", myObstacle[locationY][locationX].x , myObstacle[locationY][locationX].y );
	get_location();
	myEnemy = new component(squareSurface/2, squareSurface/2, "enemy", myObstacle[locationY][locationX].x  , myObstacle[locationY][locationX].y );
	move_to_x = myObstacle[locationY][locationX].x ;
	move_to_y = myObstacle[locationY][locationX].y ;
}
function reset_game(){
    mazeHeigth=mazeHeigth+2;
    mazeWidth=mazeWidth+2;
    turn_into_2d();
    turnVisitedInto2d();
	end = false;
    myGameArea.start();
	sketch_map();
	draw_map();
	get_location();
	myGamePiece.x = myObstacle[locationY][locationX].x;
	myGamePiece.y = myObstacle[locationY][locationX].y;
	get_location();
	myEnemy.x = myObstacle[locationY][locationX].x;
	myEnemy.y = myObstacle[locationY][locationX].y;
	move_to_x = myObstacle[locationY][locationX].x ;
	move_to_y = myObstacle[locationY][locationX].y ;
}
function get_location(){
	do {
	locationX = Math.floor(Math.random() * mazeWidth );
	locationY = Math.floor(Math.random() * mazeHeigth );
	}
	while (map[locationY][locationX] !== 0);
}
//Start loading things
var myGameArea = {  
    canvas : document.createElement("canvas"),//Load the canvas
    start : function() {
        this.canvas.width = mazeWidth * squareSurface;//The canvas width will be equal to the number of squares times their width
        this.canvas.height = mazeHeigth * squareSurface;//The canvas height will be equal to the number of squares times their heigth
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        
		//Check if no keys are pressed
        window.addEventListener('keydown', function (e) {
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        });
		//Check if any keys are pressed
        window.addEventListener('keyup', function (e) {
            myGameArea.keys[e.keyCode] = (e.type == "keydown");            
        });
    }, 
	//Clear the canvas
    clear : function(){
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },
	//Stop the game
	stop : function() {
        clearInterval(this.interval);
    }
};
//This function will manage the algorithm that will write ones, or zeroes to the screen
function sketch_map(){
	//This for loop will set all the elements of map to 1,
//	basically how this algorithm works is that you start from a canvas fll of squares and the algorithm "carves" the maze
	for (v = 0; v < mazeHeigth; v++){
		for(n = 0; n < mazeWidth; n++){
		map[v][n] = 1;
		}
	}
	//Set he beggining position of the algorithm at map[1][1]
	posX = 1;
	posY = 1;
	map[posX][posY] = 0;
	/*How this algorithm works is like this:
	1. State a beginning position
	2. Check what directions can you choose to go from that direction
	3. If there are directions available choose one randomly
	4. Continue till there are not directions available
	5. When there aren't any new directions available follow your path backwards till you find new directions
	6. Continue from step 2
	7. If there arenÂ´t any new directions in the maze you have finished*/
	do {
	while(check_carve()){
		carve();
		direction.length = 0;
	} 
	} while (!ultimate_check());
	
  }
  //Check if there's any direction that you can choose
  function check_carve (){
	var direction_carve = false;
	//Check if you can go north
	if (posY - 2 > 0 && map[posY - 2][posX] == 1 && map[posY-1][posX] == 1){
		direction.push("N");
		direction_carve = true;
	}
	//Check if you can go south
	if (posY + 2 < mazeHeigth && map[posY + 2][posX] == 1 && map[posY +1][posX] == 1){
		direction.push("S");
		direction_carve = true;
	}
	//Check if you can go west
	if (posX - 2 > 0 && map[posY][posX - 2] == 1 && map[posY][posX - 1] == 1){
		direction.push("W");
		direction_carve = true;
	}
	//Check if you can go east
	if (posX + 2 < mazeWidth && map[posY][posX + 2] && map[posY][posX + 1] == 1){ 
		direction.push("E");
		direction_carve = true;
	}
	//Output there are any directions available
	return direction_carve;
}
//Follow your path backwards
function ultimate_check(){
	var end_sketching = true;
	move--;
	//If you can keep following backwards the path
	if (move !== 0){
	posY = last_py[move];//Go to the last square that you carved
	posX = last_px[move];
	end_sketching = false;
	}
	//Output if there's still path for you to follow
	return end_sketching;
	
}
//Carve the maze, carving is done by changing the values of map from 1 to 0
function carve(){
//	Pick your available directions and choose one randomly
	var choose= Math.floor(Math.random() * direction.length);
	last_py[move] = posY;//Record your square
	last_px[move] = posX;
	switch (direction[choose]){
	//	carve the squares at your left
		case "W":
		map[posY][posX-1] = 0;
		map[posY][posX-2] = 0;
		posX -= 2;
		break;
		// carve the squares at your right
	case "E":
		map[posY][posX+1] = 0;
		map[posY][posX+2] = 0;
		posX +=2;
		break;
		//carve the squares over you
	case "N":
		map[posY-1][posX] = 0;
		map[posY-2][posX] = 0;
		last_py[move] = posY;
		posY -= 2;
		break;
		//carve the squares under you
	case "S":
		map[posY+1][posX] = 0;
		map[posY+2][posX] = 0;
		posY += 2;
		break;
	}
	move++;
}
//This fuction will translate the 1 and 0, of the map array into objects inside the myObstacle array
function draw_map(){
	
	var horizontal = 0;//horizontal coordinates
	var vertical = 0;//vertical coordinates
	//Look all the values of the map array
	var finish_line_location = Math.floor(Math.random() * 3 );
	switch  (finish_line_location){
	case 0:
		map[0][1] = 2;
		break;
	case 1:
		map[0][mazeWidth - 2] = 2;
		break;
	case 2:
		map[mazeHeigth - 2][0] = 2;
		break;
	case 3:
		map[mazeHeigth - 2][mazeWidth - 1] = 2;
		break;
	}
	for (var y = 0;  y < mazeHeigth; y++){
		for (var x = 0; x < mazeWidth; x++){
			switch (map[y][x]){
			case 0:
				myObstacle[y][x] = new component (squareSurface, squareSurface, "ground", horizontal, vertical);
				break;
			case 1:
				myObstacle[y][x] = new component (squareSurface, squareSurface, "wall", horizontal, vertical);
				break;
			case 2:
				myObstacle[y][x] = new component (squareSurface, squareSurface, "sign", horizontal, vertical);
				break;
			case 3:
				myObstacle[y][x] = new component (squareSurface, squareSurface, "question", horizontal, vertical);
				break;
			}
			horizontal += squareSurface;
			}
		horizontal = 0;
		vertical += squareSurface;
		}
}
//This function will allow the different objects have characteristics
function component(width, height, color, x, y) {
    this.gamearea = myGameArea;
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;    
    this.x = x;
    this.y = y;    
    this.update = function() {
        ctx = myGameArea.context;
		switch (color) {
		case "wall":
			ctx.drawImage(wall_image, this.x, this.y, this.width, this.height);
			break;
		case "ground":
			ctx.drawImage(ground_image, this.x, this.y, this.width, this.height);
			break;
		case "sign":
			ctx.drawImage(sign_image, this.x, this.y, this.width, this.height);
			break;
		case "question":
			ctx.drawImage(question_image, this.x, this.y, this.width, this.height);
			break;
		case "hero":
			hero_sprites( this.x, this.y, this.width, this.height);
			break;
		case "enemy":
			enemy_sprites( this.x, this.y, this.width, this.height);
			break;
		default:
			ctx.fillStyle = color;
			ctx.fillRect(this.x, this.y, this.width, this.height);
			break;
		}
    };
    this.newPos = function() {
        this.x += this.speedX;
        this.y += this.speedY;        
    };
        this.crashLeft = function(otherobj){
            var myLeft = this.x;
            var otherRight = otherobj.x + (otherobj.width);
            var myTop = this.y;
            var otherBottom = otherobj.y + (otherobj.height);
            var myBottom = this.y + (this.height);
            var otherTop = otherobj.y;
            var crashLeft = true;
            if ((myLeft !== otherRight) ||(myTop >= otherBottom ) || (myBottom <= otherTop ))  {
                crashLeft = false;
            }
            return crashLeft;
        };
         this.crashRight = function(otherobj){
            var myRight = this.x + (this.width);
            var otherLeft = otherobj.x;
            var myTop = this.y;
            var otherBottom = otherobj.y + (otherobj.height);
            var myBottom = this.y + (this.height);
            var otherTop = otherobj.y;
            var crashRight = true;
            if ((myRight !== otherLeft) ||(myTop >= otherBottom ) || (myBottom <= otherTop )){
                crashRight = false;
            }
            return crashRight;
        };
        this.crashBottom = function(otherobj){
            var myTop = this.y;
            var otherBottom = otherobj.y + (otherobj.height);
            var myLeft = this.x;
            var otherRight = otherobj.x + (otherobj.width);
            var myRight = this.x + (this.width);
            var otherLeft = otherobj.x;
            var crashBottom = true;
            if ((myTop !== otherBottom) || (myLeft >= otherRight )||(myRight <= otherLeft)){
                crashBottom = false;
            }
            return crashBottom;
        };
       this.crashTop = function(otherobj){
            var myBottom = this.y + (this.height);
            var otherTop = otherobj.y;
            var myLeft = this.x;
            var otherRight = otherobj.x + (otherobj.width);
            var myRight = this.x + (this.width);
            var otherLeft = otherobj.x;
            var crashTop = true;
            if ((myBottom !== otherTop) || (myLeft >= otherRight)|| (myRight <= otherLeft)){
                crashTop = false;
            }
            return crashTop;
        };
    
}
function hero_sprites( cha_x, cha_y, cha_width, cha_height){
			switch (hero_look){
			case "down":
				if ( myGamePiece.speedY === 1  && foot <= 10){
					ctx.drawImage(hero_image, 205, 638, 50, 70, cha_x, cha_y, cha_width, cha_height);//down 1
				}
				else if ( myGamePiece.speedY === 1  && foot > 10){
					ctx.drawImage(hero_image, 459, 638, 50, 70, cha_x, cha_y, cha_width, cha_height);// down 2
				}
				else {
					ctx.drawImage(hero_image, 76, 638, 50, 70, cha_x, cha_y, cha_width, cha_height);// down 
				}
				break;
			case "up":
				if ( myGamePiece.speedY === -1 && foot <= 10){
					ctx.drawImage(hero_image, 198, 519, 50, 69, cha_x, cha_y, cha_width, cha_height);//up 1
				}
				else if ( myGamePiece.speedY === -1 && foot > 10){
					ctx.drawImage(hero_image,453, 519, 50, 69, cha_x, cha_y, cha_width, cha_height);//up 2
				}
				else {
					ctx.drawImage(hero_image, 70, 519, 50, 69, cha_x, cha_y, cha_width, cha_height);//up
				}
				break;
			case "right":
				if ( myGamePiece.speedX === 1 && foot <= 10){
					ctx.drawImage(hero_image, 128, 707, 50, 70, cha_x, cha_y, cha_width, cha_height);//right 1
				}
				else if (myGamePiece.speedX === 1 && foot > 10){
					ctx.drawImage(hero_image, 381, 707, 50, 70, cha_x, cha_y, cha_width, cha_height);//right 2
				}
				else {
					ctx.drawImage(hero_image, 0, 707, 50, 70, cha_x, cha_y, cha_width, cha_height);//right
				}
				break;
			case "left":
				if ( myGamePiece.speedX === -1 && foot <= 10){
					ctx.drawImage(hero_image, 147, 580, 50, 70, cha_x, cha_y, cha_width, cha_height);//left 1
				}
				else if ( myGamePiece.speedX === -1 && foot > 10){
					ctx.drawImage(hero_image, 402, 580, 50, 70, cha_x, cha_y, cha_width, cha_height);//left 2
				}
				else {
					ctx.drawImage(hero_image, 20, 580, 50, 70, cha_x, cha_y, cha_width, cha_height);//left
				}
				break;
			}
			foot++;
			if (foot  >= 20 ){
			foot = 0;
			}
}
function enemy_sprites(cha_x, cha_y, cha_width, cha_height){
				switch (enemy_look){
			case "down":
				if ( myEnemy.speedY === 1  && enemy_foot <= 10){
					ctx.drawImage(enemy_image, 207, 638, 50, 70, cha_x, cha_y, cha_width, cha_height);//down 1
				}
				else if ( myEnemy.speedY === 1  && enemy_foot > 10){
					ctx.drawImage(enemy_image, 461, 638, 50, 70, cha_x, cha_y, cha_width, cha_height);// down 2
				}
				break;
			case "up":
				if ( myEnemy.speedY === -1 && enemy_foot <= 10){
					ctx.drawImage(enemy_image, 204, 519, 50, 69, cha_x, cha_y, cha_width, cha_height);//up 1
				}
				else if ( myEnemy.speedY === -1 && enemy_foot > 10){
					ctx.drawImage(enemy_image, 459, 519, 50, 69, cha_x, cha_y, cha_width, cha_height);//up 2
				}
				break;
			case "right":
				if ( myEnemy.speedX === 1 && enemy_foot <= 10){
					ctx.drawImage(enemy_image, 128, 707, 50, 70, cha_x, cha_y, cha_width, cha_height);//right 1
				}
				else if (myEnemy.speedX === 1 && enemy_foot > 10){
					ctx.drawImage(enemy_image, 381, 707, 50, 70, cha_x, cha_y, cha_width, cha_height);//right 2
				}
				break;
			case "left":
				if ( myEnemy.speedX === -1 && enemy_foot <= 10){
					ctx.drawImage(enemy_image, 147, 580, 50, 70, cha_x, cha_y, cha_width, cha_height);//left 1
				}
				else if ( myEnemy.speedX === -1 && enemy_foot > 10){
					ctx.drawImage(enemy_image, 402, 580, 50, 70, cha_x, cha_y, cha_width, cha_height);//left 2
				}
				break;
			}
			enemy_foot++;
			if (enemy_foot  >= 20 ){
			enemy_foot = 0;
			}
}
function check_obstacle_crash( i, b, object){
	var any_crash = false;
	if (object.crashLeft(myObstacle[i][b])){
        crashLeft = true;
		any_crash = true;
    }
    if (object.crashRight(myObstacle[i][b])){
        crashRight = true;
		any_crash = true;
    }
    if (object.crashTop(myObstacle[i][b])){
        crashTop = true;
		any_crash = true;
    }
    if (object.crashBottom(myObstacle[i][b])){
        crashBottom = true;
		any_crash = true;
	}
	return any_crash;
}
function check_enemy_crash(){
	if (myGamePiece.crashLeft(myEnemy)){
		end = true;
    }
    if (myGamePiece.crashRight(myEnemy)){
        end = true;
    }
    if (myGamePiece.crashTop(myEnemy)){
        end = true;
    }
    if (myGamePiece.crashBottom(myEnemy)){
        end = true;
	}
}
function check_enemy_direction(){
	visited[locationY][locationX] = true;
	var walk = false;
	if (map[locationY - 1][locationX] === 0 && !visited[locationY - 1][locationX]){
		direction.push("N");
		walk = true;
	}
	if (map[locationY + 1][locationX] === 0 && !visited[locationY + 1][locationX]){
		direction.push("S");
		walk = true
	}
	if (map[locationY][locationX - 1] === 0 && !visited[locationY][locationX - 1]){
		direction.push("W");
		walk = true;
	}
	if (map[locationY][locationX + 1] === 0 && !visited[locationY][locationX + 1]){
		direction.push("E");
		walk = true;
	}
	if (!walk) {
		for (n = 0; n < mazeHeigth; n++){
			for (m = 0; m < mazeWidth; m++){
				visited[n][m] = false;
			}
		}
	}
}
function enemy_move(){
	myEnemy.speedX = 0;
	myEnemy.speedY = 0;
	var choose_direction = Math.floor(Math.random() * direction.length );
	switch (direction[choose_direction]){
	case "N":
		enemy_look = "up";
		myEnemy.speedY = -1;
		locationY--;
		move_to_y = myObstacle[locationY][locationX].y;
		break;
	case "S":
		enemy_look = "down";
		myEnemy.speedY = 1;
		locationY++;
		move_to_y = myObstacle[locationY][locationX].y;
		break;
	case "W":
		enemy_look = "left";
		myEnemy.speedX = -1;
		locationX--;
		move_to_x = myObstacle[locationY][locationX].x;
		break;
	case "E":
		enemy_look = "right";
		myEnemy.speedX = 1;
		locationX++;
		move_to_x = myObstacle[locationY][locationX].x;
		break;
	}
	direction.length = 0;
}
function updateGameArea() {
    myGameArea.clear();
    crashLeft = false;
    crashRight = false;
    crashTop = false;
    crashBottom = false;
	end = false;
	myGamePiece.speedX = 0;
	myGamePiece.speedY = 0;
	//Check for collisions, and, if there's a collision with a blue block, set end value to true
    for (i= 0; i< mazeHeigth;i++){
		for (var b = 0; b <mazeWidth; b++){
			switch (map[i][b]){
			case 0:
				break;
			case 1:
				check_obstacle_crash(i,b, myGamePiece);
				break;
			case 2:
				if (check_obstacle_crash(i,b, myGamePiece)){
					end = true;
				}
				break;
			}
        }
	}
	check_enemy_crash();
	//move the red square
	    if (myGameArea.keys && myGameArea.keys[37] && !crashLeft ) {
				myGamePiece.speedX = -1;
				hero_look = "left";
	}
    else if (myGameArea.keys && myGameArea.keys[39] && !crashRight ) {
				myGamePiece.speedX =1;
				hero_look = "right";
	}
    else if (myGameArea.keys && myGameArea.keys[38] && !crashBottom ) {
				myGamePiece.speedY = -1;
				hero_look = "up";
	}
    else if (myGameArea.keys && myGameArea.keys[40] && !crashTop ){
				myGamePiece.speedY = 1;
				hero_look = "down";
	}
	//Update myObtacle position
    for (i = 0; i < mazeHeigth; i++){
		for (var c=0; c <mazeWidth; c++){
    myObstacle[i][c].update();
	}
    } 
//Update the red square position	
	myGamePiece.newPos();
    myGamePiece.update();
	if (myEnemy.x === move_to_x && myEnemy.y === move_to_y){
	check_enemy_direction();
	enemy_move();
	}
	myEnemy.newPos();
	myEnemy.update();
	if (end){//if end is true stop the game and write Game Over!!!
	reset_game();
	
	}
}
</script>
</body>
</html>